{-# LANGUAGE DataKinds #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
module VCGMacaw
  ( declRegs
  , smtRegVar
  , blockEvents
  , Event(..)
  , ppEvent
  , memVar
  , evenParityDecl
  ) where

import           Control.Lens
import           Control.Monad
import           Control.Monad.Cont
import           Control.Monad.Reader
import           Control.Monad.ST
import           Control.Monad.State
import           Data.Macaw.CFG as M
import           Data.Macaw.CFG.Block
import qualified Data.Macaw.Types as M
import           Data.Macaw.X86
import           Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import           Data.Parameterized.NatRepr
import           Data.Parameterized.Nonce
import           Data.Parameterized.Some
import           Data.Parameterized.TraversableF
import           Data.Set (Set)
import qualified Data.Set as Set
import           Data.Text (Text)
import qualified Data.Text as Text
import           Data.Word
import           GHC.Stack
import           Text.PrettyPrint.ANSI.Leijen as PP hiding ((<$>))
import qualified What4.Protocol.SMTLib2.Syntax as SMT

import           VCGCommon

smtRegVar :: X86Reg tp -> Text
smtRegVar reg = "x86reg_" <> Text.pack (show reg)

smtLocalVar :: AssignId ids tp -> Text
smtLocalVar (AssignId n) = "x86local_" <> Text.pack (show (indexValue n))

macawError :: HasCallStack => String -> a
macawError msg = error $ "[Macaw Error] " ++ msg

initReg :: X86Reg tp
        -> Const SMT.Term tp
initReg reg = Const $ varTerm (smtRegVar reg)

evalMemAddr :: Map RegionIndex SMT.Term
            -> MemAddr 64
            -> SMT.Term
evalMemAddr m a =
  case Map.lookup (addrBase a) m of
    Nothing -> error "evalMemAddr given address with bad region index."
    Just b -> SMT.bvadd b [SMT.bvdecimal (toInteger (addrOffset a)) 64]

memVar :: Integer -> Text
memVar i = "x86mem_" <> Text.pack (show i)

initRegDecl :: X86Reg tp
            -> SMT.Command
initRegDecl reg = SMT.declareFun (smtRegVar reg) [] (toSMTType (M.typeRepr reg))

------------------------------------------------------------------------
-- Event


-- | One of the events generated by running a Macaw block.
data Event
  = CmdEvent !SMT.Command
  | WarningEvent !String
    -- ^ We added a warning about an issue in the VCG
  | InstructionEvent !(MemSegmentOff 64)
    -- ^ Marker to indicate the instruction at the given address will be executed.
  | ReadEvent !SMT.Term !Integer !Var
    -- ^ `ReadEvent a w v` indicates that we read `w` bytes from `a`,
    -- and assign the value returned to `v`.
  | CondReadEvent !SMT.Term !SMT.Term !Integer !SMT.Term !Var
    -- ^ `CondReadEvent c a w d v` indicates that we read `w` bytes from `a` when
    -- condition `c` holds, and assign the return value to `v`.   When `c`
    -- is false, then assign `d` to `v`.
  | WriteEvent !SMT.Term !Integer !SMT.Term
    -- ^ `WriteEvent a w v` indicates that we write the `w` byte value `v`  to `a`.
    --
    -- This has side effects, so we record the event.
  | FetchAndExecuteEvent !(RegState (ArchReg X86_64) (Const SMT.Term))

  | BranchEvent !SMT.Term
                !(RegState (ArchReg X86_64) (Const SMT.Term))
                !(RegState (ArchReg X86_64) (Const SMT.Term))

ppEvent :: Event
        -> String
ppEvent (InstructionEvent _) = "instruction"
ppEvent (WarningEvent _) = "warning"
ppEvent CmdEvent{} = "cmd"
ppEvent ReadEvent{} = "read"
ppEvent CondReadEvent{} = "condRead"
ppEvent WriteEvent{} = "write"
ppEvent (FetchAndExecuteEvent _) = "fetchAndExecute"
ppEvent (BranchEvent _ _ _) = "branch"

instance Show Event where
  show = ppEvent


------------------------------------------------------------------------
-- MStateM


data MState = MState
  { blockStartAddr :: !(MemSegmentOff 64)
    -- ^ Initial address of block.
  , initRegs :: !(RegState X86Reg (Const SMT.Term))
  , locals   :: !(Set Word64)
    -- ^ Indices of assignments added so far.
  }

newtype MStateM a = MStateM (ContT [Event] (Reader MState) a)
  deriving (Functor, Applicative, Monad)

instance MonadState MState MStateM where
  get   = MStateM $ lift $ ask
  put t = MStateM $ ContT $ \c -> ReaderT $ \_ -> runReaderT (c ()) t

runMStateM :: MemSegmentOff 64 -> RegState X86Reg (Const SMT.Term) -> MStateM () -> [Event]
runMStateM addr regs (MStateM f) =
  let ms0 = MState { blockStartAddr = addr
                   , initRegs = regs
                   , locals = Set.empty
                   }
   in runReader (runContT f (\() -> pure [])) ms0

addEvent :: Event -> MStateM ()
addEvent e = MStateM $ ContT $ \c -> ReaderT $ \s -> Identity (e : runReader (c ()) s)

addCommand :: SMT.Command -> MStateM ()
addCommand cmd = addEvent $ CmdEvent cmd

addWarning :: String -> MStateM ()
addWarning msg = addEvent $ WarningEvent msg

------------------------------------------------------------------------
-- Translation

primEval :: Value X86_64 ids tp
         -> MStateM SMT.Term
primEval (BVValue w i) = do
  pure $ SMT.bvdecimal i (natValue w)

primEval (BoolValue b) = do
  pure $ if b then SMT.true else SMT.false

primEval (AssignedValue (Assignment (AssignId ident) _rhs)) = do
  m <- locals <$> get
  when (Set.notMember (indexValue ident) m) $ do
    macawError $ "Not contained in the locals: " ++ show ident
  return $! varTerm (smtLocalVar (AssignId ident))

primEval (Initial reg) = do
  regs <- initRegs <$> get
  case regs^.boundValue reg of
    Const e -> pure e

primEval (RelocatableValue _w addr) = do
  let m = error "region index map not defined."
  pure $ evalMemAddr m addr

primEval (SymbolValue _w _id) = do
  macawError "SymbolValue: Not implemented yet"

evalToMSymExpr :: Value X86_64 ids tp -> MStateM (Const SMT.Term tp)
evalToMSymExpr v = Const <$> primEval v

toSMTType :: M.TypeRepr tp -> SMT.Sort
toSMTType (M.BVTypeRepr w) = SMT.bvSort (natValue w)
toSMTType M.BoolTypeRepr = SMT.boolSort
toSMTType tp = error $ "toSMTType: unsupported type " ++ show tp

{-
readMem :: SMT.Term
        -> M.MemRepr tp
        -> MStateM SMT.Term
readMem ptr (BVMemRepr w end) = do
  when (end /= LittleEndian) $ do
    error "reopt-vcg only encountered big endian read."
  -- TODO: Add assertion that memory is valid.
  mem <- gets curMem
  pure $ readBVLE mem ptr (natValue w)

writeMem :: SMT.Term
         -> M.MemRepr tp
         -> SMT.Term
         -> MStateM ()
writeMem ptr (BVMemRepr w LittleEndian) val = do
  modify' $ \s ->
    let SMem newMem = writeBVLE (curMem s) ptr val (natValue w)
        cmd = SMT.defineFun (memVar (memIndex s)) [] memSort newMem
     in s { curMem = SMem (varTerm (memVar (memIndex s)))
          , memIndex = memIndex s + 1
          , events = CmdEvent cmd : events s
          }
-}

-- | Record that the given assign id has been set.
recordLocal :: AssignId ids tp
            -> MStateM ()
recordLocal (AssignId n) = do
  modify $ \s -> s { locals = Set.insert (indexValue n) (locals s) }

-- | Add a command to declare the SMT var with the given local name and Macaw type.
setUndefined :: AssignId ids tp
             -> M.TypeRepr tp
             -> MStateM ()
setUndefined aid tp = do
  addCommand $ SMT.declareFun (smtLocalVar aid) [] (toSMTType tp)

evalApp2SMT :: AssignId ids tp
            -> App (Value X86_64 ids) tp
            -> MStateM ()
evalApp2SMT aid a = do
  let doSet v = do
        let tp = toSMTType (M.typeRepr a)
        addCommand $ SMT.defineFun (smtLocalVar aid) [] tp v
  case a of
    BVAdd _w x y -> do
      xv  <- primEval x
      yv  <- primEval y
      doSet $ SMT.bvadd xv [yv]
    BVSub _w x y -> do
      xv  <- primEval x
      yv  <- primEval y
      doSet $ SMT.bvsub xv yv
    BVMul _w x y -> do
      xv  <- primEval x
      yv  <- primEval y
      doSet $ SMT.bvmul xv [yv]
    BVUnsignedLe x y -> do
      xv <- primEval x
      yv <- primEval y
      doSet $ SMT.bvule xv yv
    BVUnsignedLt x y -> do
      xv <- primEval x
      yv <- primEval y
      doSet $ SMT.bvult xv yv
    BVSignedLe x y -> do
      xv <- primEval x
      yv <- primEval y
      doSet $ SMT.bvsle xv yv
    BVSignedLt x y -> do
      xv <- primEval x
      yv <- primEval y
      doSet $ SMT.bvslt xv yv
    Eq x y -> do
      xv <- primEval x
      yv <- primEval y
      doSet $ SMT.eq [xv,yv]
    OrApp x y -> do
      xv <- primEval x
      yv <- primEval y
      doSet $ SMT.or [xv,yv]
    Trunc x w -> do
      xv <- primEval x
      -- Given the assumption that all data are 64bv, treat it as no ops for the moment.
      doSet $ SMT.extract (natValue w-1) 0 xv
    SExt x w -> do
      xv <- primEval x
      -- This sign extends x
      doSet $ SMT.bvsignExtend (natValue w-natValue (M.typeWidth x)) xv
    UExt x w -> do
      xv <- primEval x
      -- This sign extends x
      doSet $ SMT.bvzeroExtend (natValue w-natValue (M.typeWidth x)) xv
    UadcOverflows x y c -> do
      -- We check for unsigned overflow by zero-extending x, y, and c, performing the
      -- addition, and seeing if the most signicant bit is non-zero.
      xv <- primEval x
      yv <- primEval y
      cv <- primEval c
      let w :: Integer
          w = natValue (M.typeWidth x)
      -- Do zero extensions
      let xext = SMT.bvzeroExtend 1 xv
      let yext = SMT.bvzeroExtend 1 yv
      let cext = SMT.bvzeroExtend w (SMT.ite cv SMT.bit1 SMT.bit0)
      -- Perform addition
      let rext = SMT.bvadd xext [yext, cext]
      -- Unsigned overflow occurs if most-significant bit is set.
      doSet $ SMT.eq [SMT.extract w w rext, SMT.bit1]
    SadcOverflows x y c -> do
      -- We check for signed overflow by adding x, y, and c, checking two things:
      -- x & y have the same sign, and c has t

      -- addition, and seeing if the most signicant bit is non-zero.
      xv <- primEval x
      yv <- primEval y
      cv <- primEval c
      let w :: Integer
          w = natValue (M.typeWidth x)
      -- Carry is positive.
      let cext = SMT.bvzeroExtend (w-1) (SMT.ite cv SMT.bit1 SMT.bit0)
      -- Perform addition
      let r = SMT.bvadd xv [yv, cext]
      -- Check sign property.
      let xmsb = SMT.extract (w-1) (w-1) xv
      let ymsb = SMT.extract (w-1) (w-1) yv
      let rmsb = SMT.extract (w-1) (w-1) r

      doSet $ SMT.and [SMT.eq [xmsb, ymsb], SMT.distinct [xmsb, rmsb]]

    _app -> do
      addWarning $ "TODO: Implement " ++ show (ppApp (\_ -> text "*") a) ++ "."
      setUndefined aid (M.typeRepr a)

-- | Declaration of even-parity function.
evenParityDecl :: SMT.Command
evenParityDecl =
  let v = varTerm "v"
      bitTerm = SMT.bvxor (SMT.extract 0 0 v) [ SMT.extract i i v | i <- [1..7] ]
      r = SMT.eq [bitTerm, SMT.bvbinary 0 1]
   in SMT.defineFun "even_parity" [("v", SMT.bvSort 8)] SMT.boolSort r

x86PrimFnToSMT :: AssignId ids tp
               -> X86PrimFn (Value X86_64 ids) tp
               -> MStateM ()
x86PrimFnToSMT aid (EvenParity a) = do
  xv <- primEval a
  addCommand $ SMT.defineFun (smtLocalVar aid) [] SMT.boolSort (SMT.term_app "even_parity" [xv])
x86PrimFnToSMT aid prim = do
  addWarning $ "TODO: Implement " ++ show (runIdentity (ppArchFn (Identity . ppValue 10) prim))
  setUndefined aid (M.typeRepr prim)

assignRhs2SMT :: AssignId ids tp
              -> AssignRhs X86_64 (Value X86_64 ids) tp
              -> MStateM ()
assignRhs2SMT aid rhs = do
  case rhs of
    EvalApp a -> do
      evalApp2SMT aid a

    ReadMem addr (BVMemRepr w end) -> do
      when (end /= LittleEndian) $ do
        error "reopt-vcg only encountered big endian read."
      addrTerm <- primEval addr
      -- Add conditional read event.
      addEvent $ ReadEvent addrTerm (natValue w) (smtLocalVar aid)

    CondReadMem (BVMemRepr w end) cond addr def -> do
      when (end /= LittleEndian) $ do
        error "reopt-vcg only encountered big endian read."
      condTerm <- primEval cond
      addrTerm <- primEval addr
      defTerm <- primEval def

      -- Assert that value = default when cond is false
      -- Add conditional read event.
      addEvent $ CondReadEvent condTerm addrTerm (natValue w) defTerm (smtLocalVar aid)

    SetUndefined tp -> do
      setUndefined aid tp

    EvalArchFn f _tp -> do
      x86PrimFnToSMT aid f

stmt2SMT :: Stmt X86_64 ids -> MStateM ()
stmt2SMT stmt =
  case stmt of
    AssignStmt (Assignment aid rhs) -> do
      recordLocal aid
      assignRhs2SMT aid rhs
    WriteMem addr (BVMemRepr w end) val -> do
      when (end /= LittleEndian) $ do
        error "reopt-vcg only encountered big endian read."
      -- TODO: dealing with memory representation
      addrTerm <- primEval addr
      valTerm  <- primEval val
      addEvent $ WriteEvent addrTerm (natValue w) valTerm
    InstructionStart off _mnem -> do
      blockAddr <- gets blockStartAddr
      let Just addr = incSegmentOff blockAddr (toInteger off)
      addEvent $ InstructionEvent addr
    Comment _s -> return ()                 -- NoOps
    ArchState _a _m -> return ()             -- NoOps
    ExecArchStmt{} -> error "stmt2SMT unsupported statement."

{-
-- | Attempt to interpret the statement list as just a jump to the given address with
-- the registers provided.
blockAsJump :: forall ids
            .  Map Word64 (Block X86_64 ids)
            -> Word64
            -> MStateM (RegState (ArchReg X86_64) (Const SMT.Term))
blockAsJump blockMap off =
  case Map.lookup off blockMap of
    Nothing -> do
      error $ "Can not find block offset " ++ show off
    Just b -> do
      unless (null (blockStmts b)) $ do
        error $ "Branch doesn't support other nonterminal statements."
      case blockTerm b of
        FetchAndExecute s -> do
          traverseF evalToMSymExpr s
        s -> error $ "Unsupported branch terminal: " ++ show (pretty s)
-}

termStmt2SMT :: TermStmt X86_64 ids
             -> MStateM ()
termStmt2SMT tstmt =
  case tstmt of
    FetchAndExecute st -> do
      regs <- traverseF evalToMSymExpr st
      addEvent $ FetchAndExecuteEvent regs
    Branch{} ->
      error "Unexpected branch"
    TranslateError _regs msg ->
      error $ "TranslateError : " ++ Text.unpack msg
    ArchTermStmt stmt _regs ->
      error $ "Unsupported : " ++ show (prettyF stmt)

block2SMT :: Block X86_64 ids
          -> MStateM ()
block2SMT b = do
  mapM_ stmt2SMT (blockStmts b)
  termStmt2SMT (blockTerm b)

declRegs :: [SMT.Command]
declRegs = (\(Some r) -> initRegDecl r) <$> archRegs

blockEvents :: MemSegmentOff 64 -> Integer -> [Event]
blockEvents addr sz = runST $ do
  Some stGen <- newSTNonceGenerator
  let loc = rootLoc addr
  mBlock <- disassembleFixedBlock stGen loc (fromIntegral sz)
  case mBlock of
    Left err ->
      error $ "Translation error: " ++ show err
    Right b ->
      pure $! runMStateM addr (mkRegState initReg) (block2SMT b)
